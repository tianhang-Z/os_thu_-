[toc]

## 虚拟技术的起因

程序规模的增长速度远大于内存容量的增长速度

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109212210522.png" alt="image-20231109212210522" style="zoom:80%;" />

由于硬盘太慢，程序运行需要放在内存中

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109212952023.png" alt="image-20231109212952023" style="zoom:80%;" />

程序全放进内存放不下，把程序常用的数据和指令放在内存

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109213219436.png" alt="image-20231109213219436" style="zoom:80%;" />

后面介绍这三种技术

## 覆盖技术

解决程序大的问题，属于比较老的技术  DOS系统用的

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109213624906.png" alt="image-20231109213624906" style="zoom:80%;" />

独立的模块，分时共享同一空间

eg：

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109213829177.png" alt="image-20231109213829177" style="zoom:80%;" />

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109214028733.png" alt="image-20231109214028733" style="zoom:80%;" />

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109214130474.png" alt="image-20231109214130474" style="zoom:80%;" />

缺点：程序模块划分费时，频繁的交换带来时间开销

## 交换技术

解决多个程序的问题  来自unix

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231109214427252.png" alt="image-20231109214427252" style="zoom:80%;" />

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114141305727.png" alt="image-20231114141305727" style="zoom:80%;" />

程序换入换出有时间开销

![image-20231114141843191](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114141843191.png)

![image-20231114141927438](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114141927438.png)

## 虚存技术

<img src="./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114161817228.png" alt="image-20231114161817228" style="zoom:80%;" />

能否结合二者的优点

![image-20231114161950955](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114161950955.png)

![image-20231114162133758](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114162133758.png)

 ![image-20231114162433638](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114162433638.png)

int 是32位，页大小为4k，可保存1024个int

![image-20231114162620659](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114162620659.png)

写法二的局部性更好

**基于分页或分段机制实现 ** 

相比于交换技术，其单位是整个进程；虚拟技术的粒度更小

![image-20231114163922972](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114163922972.png)

![image-20231114164206583](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114164206583.png)

**实现**

![image-20231114164318091](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114164318091.png)

![image-20231114165928949](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114165928949.png)

![image-20231114170455993](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114170455993.png)

eg:

![image-20231114172018129](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114172018129.png)

MOV REG,0   把虚拟地址0的字节写入REG寄存器

0处页表帧号为2   则有对应帧 驻留位为1

MOV REG，32780    32780对应第8页   **无对应帧 产生缺页中断**

![image-20231114172207841](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114172207841.png)

![image-20231114172531686](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114172531686.png)



**开销计算**

![image-20231114172918019](./image/image_5.%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20231114172918019.png)

q代表内存中的数据被修改，释放时需要写回硬盘