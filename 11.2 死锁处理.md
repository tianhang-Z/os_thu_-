[toc]

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231120214501818.png" alt="image-20231120214501818" style="zoom: 80%;" />

## 死锁预防

**确保不会出现死锁，约束太强，会限制操作系统功能；**

放松一点，允许出现，能恢复就好；

或者直接忽略：原因是，1 死锁难以判断 ；2，影响OS功能

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231120214628055.png" alt="image-20231120214628055" style="zoom:80%;" />

#### 预防方法

<img src="./image_11.1%20%E6%AD%BB%E9%94%81%E4%BB%8B%E7%BB%8D/image-20231120214249284.png" alt="image-20231120214249284" style="zoom:80%;" />

**打破上述几个条件**

1，互斥不好打破；

2，占用并等待：使进程要么获得全部资源，要么一个都不获得；但有缺点

3，无抢占：进程所需资源无法获得时，释放已有资源； 

4，循环等待：资源有编号，按照资源顺序进行申请；（编号由小到大，则不会有环形成）；在嵌入式系统应用多，因为其资源类型和数量少。

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125095300491.png" alt="image-20231125095300491" style="zoom:80%;" /><img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125095552289.png" alt="image-20231125095552289" style="zoom:80%;" />

## 死锁避免

要求更松，判断是否导致死锁，避免导致；通过一个方法，在进程申请资源时，判断申请合不合理；但需要一些信息进行判断

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125095749259.png" alt="image-20231125095749259" style="zoom:80%;" />

环形等待未必会有死锁，但也是一种不安全状态；

 #### 安全状态

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125100405772.png" alt="image-20231125100405772" style="zoom:80%;" />

#### 几个状态的关系

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125100558060.png" alt="image-20231125100558060" style="zoom: 80%;" />

#### 银行家算法

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125102310738.png" alt="image-20231125102310738" style="zoom:80%;" />

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125102719379.png" alt="image-20231125102719379" style="zoom:80%;" />

##### 安全状态估计算法

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125103311478.png" alt="image-20231125103311478" style="zoom:80%;" />

##### 结合银行家算法

**核心思想：假设分配资源给进程请求，重新判断安全状态**

下述1和2，需要判断两次安全状态

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125104014462.png" alt="image-20231125104014462" style="zoom:80%;" />

Pi若执行，重新估计状态是否安全，若不安全（即不能形成安全序列），则进行Pi不能执行；否则，可以执行。

##### 例子1

1，初始状态

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125104215423.png" alt="image-20231125104215423" style="zoom:80%;" />

2.1，P2的Need小于Available，可执行，然后结束释放资源

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125104426724.png" alt="image-20231125104426724" style="zoom:80%;" />

2.2  P1也可执行，然后结束

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125104514369.png" alt="image-20231125104514369" style="zoom:80%;" />

2.3 后续P3 P4也可执行

##### 例子2

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125104907598.png" alt="image-20231125104907598" style="zoom:80%;" />

此时P1 request 1 0 1 ，其小于Available，则修改对应状态，判断是否安全

修改后如下：

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125105109259.png" alt="image-20231125105109259" style="zoom:80%;" />

易知不安全

## 死锁检测

条件进一步放松：允许死锁，进行检测和恢复

##### 算法介绍

**方法1：对资源分配图简化，变成等待图，看图是否有环，有环可能死锁**

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125105517732.png" alt="image-20231125105517732" style="zoom:80%;" />

**方法2：**

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125105619304.png" alt="image-20231125105619304" style="zoom:80%;" />

算法如下：类似银行家算法

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125140005313.png" alt="image-20231125140005313" style="zoom:80%;" />

算法开销比较大，且需要预知进程需要多少资源，这是很难做到的，因此实际应用很少；调试时可能用到。

##### 例子

P0->P2->P1->...

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125140619286.png" alt="image-20231125140619286" style="zoom:80%;" />

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125140656535.png" alt="image-20231125140656535" style="zoom:80%;" />

##### 何时使用

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125141253733.png" alt="image-20231125141253733" style="zoom:80%;" />



## 死锁恢复

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125141413836.png" alt="image-20231125141413836" style="zoom:80%;" />

kill的依据：低优先级；耗时长的；占资源多的....

其他方法：资源抢占

<img src="./image_11.2%20%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/image-20231125141554863.png" alt="image-20231125141554863" style="zoom:80%;" />
