[toc]

## 1.启动

DISK：存放OS 和bootloader（加载OS）

BIOS：基本IO处理系统，检测各种外设

**注意：**==BIOS不在DISK中，而是在主板的一个ROM芯片上==

#### 计算机的启动过程：

##### BIOS的工作：

<img src="./image/image_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20231103144632965.png" alt="image-20231103144632965" style="zoom:67%;" />

BIOS从指定的地址开始执行，该地址为CS:IP（CS：IP地址的内容被CPU执行），

**之后进行POST**（加电自检，检测CPU,内存，显卡，磁盘等设备是否可以正常工作），

然后进行初始化，创建中断向量，设置寄存器，外部设备的参数等

**然后从DISK寻找bootloader**，将其放入内存的**0x7c00**位置，然后将CPU的控制权交给bootloader，即CS:IP指向0x7c00，由loader加载OS。

**注意：**bootloader一般在DISK的第一个扇区（比较好找），也叫主引导扇区，共512字节。

<img src="./image/image_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20231103150104869.png" alt="image-20231103150104869" style="zoom: 80%;" />

##### booloader的工作：

将OS的代码和数据加载到内存中，并将CPU的控制权交给OS（即CS:IP指向OS的启示地址）

## 2. 系统调用，异常，中断

### 定义

* 中断 来源于外设：来自不同的硬件设备的计时器和网络的中断，即外设的请求

* 系统调用 来源于应用程序：应用程序向OS提出服务请求
* 异常 来自不良的应用程序：非法指令或者异常的状态，是应用程序意想不到的行为

在计算机运行时，只有内核kernel是被信任的，可以执行特权指令，而应用程序是不被信任的。

因此应用程序不能直接访问外设，需要请求。

同时，利用OS屏蔽外设的复杂性，为上层应用程序提供简单的接口。

### 特点和差异

**来源不同**

**处理时间不同：**

* 中断：异步        不知道何时触发
* 异常：同步       触发时其正在执行的指令位置是确定的
* 系统调用：异步或者同步，（应用程序发生请求，发送的节点是同步的，其得到的回应是异步的，可能会有延时

##### 响应

* 中断：持续响应，且对用户应用程序是透明的，即感受不到，由OS默默处理
* 异常：杀死或重新执行应用程序指令
* 系统调用：等待或持续

### 中断和异常的处理机制

给不同中断进行编号，并设置好相应的服务程序，并注意原程序的现场保护

异常也要编号，但是异常可能没有对应服务，异常的处理程序可以是杀死异常程序或者重新执行异常指令，也可能有对异常的服务来修补异常，因此也要保存和恢复现场

### 系统调用

系统调用接口，为应用程序提供服务

eg：应用程序调用printf()时，会请求使用系统的write()

即，OS提供**API**：Application Programming Interface

因此，如何设计和实现API很重要

**系统调用时，从用户态向内核态转变，堆栈切换**；而函数调用不会



### 开销

<img src="./image/image_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20231103154615249.png" alt="image-20231103154615249" style="zoom:80%;" />

应用程序堆栈的保存与恢复

数据从内核态到用户态的地址空间，数据拷贝的开销

